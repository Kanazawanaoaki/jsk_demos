(defun curry-state-ask ()
  (warn "Please check. Is it going well? ~%")
  (setq ans (read))
  (format t "Your answer is ~A. ~%" ans)
  (if (eql ans 'yes) :success :fail)
  )

(defun string-cb (msg)
  (setq *msg* msg)
  (setq *data* (send msg :data))
  (format t "data is ~A ~%" *data*)
  (setq *msg-flag* t)
  )


(defun init ()
  (ros::roseus "smach-shelf-funcs" :anonymous t)
  (ros::load-ros-manifest "roseus")
  (ros::subscribe "smach_state_msg" std_msgs::string #'string-cb 1)
  (warn "init! ~%")
  )

(defun off ()
  (warn "state: off ~%")
  (setq *msg-flag* nil)
  (until *msg-flag*
         (ros::spin-once)
         (ros::sleep)
         )
  (if (equal *data* "open") ;; case文使って書いても良いかも
      (return-from off :open))
  (if (equal *data* "finish")
      (return-from off :finish)
    (off)
    )
  )

(defun open ()
  (warn "state: open ~%")
  (setq *msg-flag* nil)
  (until *msg-flag*
         (ros::spin-once)
         (ros::sleep)
         )
  (cond
   ((equal *data* "close")
    (return-from open :close))
   )
  (open)
  )

(defun 0s ()
  (warn "state: 0s ~%")
  (setq *msg-flag* nil)
  (until *msg-flag*
         (ros::spin-once)
         (ros::sleep)
         )
  (cond
   ((equal *data* "finish")
    (return-from 0s :finish))
   ((equal *data* "off")
    (return-from 0s :off))
   ((equal *data* "500w")
    (return-from 0s :500w))
   ((equal *data* "open")
    (return-from 0s :open))
   )
  (0s)
  )

(defun 500w ()
  (warn "state: 500w ~%")
  (setq *msg-flag* nil)
  (until *msg-flag*
         (ros::spin-once)
         (ros::sleep)
         )
  (cond
   ((equal *data* "1min")
    (return-from 500w :1min))
   ((equal *data* "open")
    (return-from 500w :open))
   ((equal *data* "0s")
    (return-from 500w :0s))
   )
  (500w)
  )

(defun 1min ()
  (warn "state: 1min ~%")
  (setq *msg-flag* nil)
  (until *msg-flag*
         (ros::spin-once)
         (ros::sleep)
         )
  (cond
   ((equal *data* "2min")
    (return-from 1min :2min))
   ((equal *data* "3min")
    (return-from 1min :3min))
   ((equal *data* "open")
    (return-from 1min :open))
   ((equal *data* "0s")
    (return-from 1min :0s))
   ((equal *data* "heating")
    (return-from 1min :heating))
   )
  (1min)
  )

(defun 2min ()
  (warn "state: 2min ~%")
  (setq *msg-flag* nil)
  (until *msg-flag*
         (ros::spin-once)
         (ros::sleep)
         )
  (cond
   ((equal *data* "3min")
    (return-from 2min :3min))
   ((equal *data* "open")
    (return-from 2min :open))
   ((equal *data* "0s")
    (return-from 2min :0s))
   ((equal *data* "heating")
    (return-from 2min :heating))
   )
  (2min)
  )

(defun 3min ()
  (warn "state: 3min ~%")
  (setq *msg-flag* nil)
  (until *msg-flag*
         (ros::spin-once)
         (ros::sleep)
         )
  (cond
   ((equal *data* "open")
    (return-from 3min :open))
   ((equal *data* "0s")
    (return-from 3min :0s))
   ((equal *data* "heating")
    (return-from 3min :heating))
   )
  (3min)
  )

(defun heating ()
  (warn "state: heating ~%")
  (setq *msg-flag* nil)
  (until *msg-flag*
         (ros::spin-once)
         (ros::sleep)
         )
  (cond
   ((equal *data* "time-elapsed")
    (return-from heating :time-elapsed))
   )
  (heating)
  )

