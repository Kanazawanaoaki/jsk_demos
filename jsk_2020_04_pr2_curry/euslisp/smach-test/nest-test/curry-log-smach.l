#!/usr/bin/env roseus

(load "package://roseus_smach/src/state-machine.l")
(load "package://roseus_smach/src/state-machine-ros.l")
(load "package://roseus_smach/src/state-machine-utils.l")

(load "curry-log-funcs.l")

(defun smach-curry-test ()
  (let ((sm-top (instance state-machine :init))
        (sm-sub-0 (instance state-machine :init))        
        (sm-sub-1 (instance state-machine :init))
        (sm-sub-2 (instance state-machine :init))
        (sm-sub-3 (instance state-machine :init))
        (sm-sub-4 (instance state-machine :init))
        (sm-sub-5 (instance state-machine :init))
        (sm-sub-6 (instance state-machine :init))
        (sm-sub-7 (instance state-machine :init))
        (sm-sub-8 (instance state-machine :init))
        (sm-sub-9 (instance state-machine :init))
        )
    ;; state instance can include other state-machine like function
    (send sm-top :add-node (instance state :init "PREPARATION" sm-sub-0))
    ;; (send sm-top :add-node (instance state :init "PREPARATION" '(lambda (&rest args) (curry-0) :success)))
    (send sm-top :add-node (instance state :init "CARROT-PREPARATION" sm-sub-1))
    ;; (send sm-top :add-node (instance state :init "CARROT-PREPARATION" '(lambda (&rest args) (curry-1) :success)))
    (send sm-top :add-node (instance state :init "POTATO-PREPARATION" sm-sub-2))
    ;; (send sm-top :add-node (instance state :init "POTATO-PREPARATION" '(lambda (&rest args) (curry-2) :success)))
    (send sm-top :add-node (instance state :init "ONION-PREPARATION" sm-sub-3))
    ;; (send sm-top :add-node (instance state :init "ONION-PREPARATION" '(lambda (&rest args) (curry-3) :success)))
    (send sm-top :add-node (instance state :init "FRY-PREPARATION" sm-sub-4))
    ;; (send sm-top :add-node (instance state :init "FRY-PREPARATION" '(lambda (&rest args) (curry-4) :success)))
    (send sm-top :add-node (instance state :init "FRY-ONION" '(lambda (&rest args) (curry-5) :success)))
    (send sm-top :add-node (instance state :init "FRY-MEAT" '(lambda (&rest args) (curry-6) :success)))
    (send sm-top :add-node (instance state :init "STEW-PREPARATION" '(lambda (&rest args) (curry-7) :success)))
    (send sm-top :add-node (instance state :init "STEW" '(lambda (&rest args) (curry-8) :success)))
    (send sm-top :add-node (instance state :init "CURRY-ROUX" '(lambda (&rest args) (curry-9) :success)))
    (send sm-top :goal-state :done)
    (send sm-top :start-state "PREPARATION")
    (send sm-top :add-transition "PREPARATION" "CARROT-PREPARATION" :success)
    (send sm-top :add-transition "CARROT-PREPARATION" "POTATO-PREPARATION" :success)
    (send sm-top :add-transition "POTATO-PREPARATION" "ONION-PREPARATION" :success)
    (send sm-top :add-transition "ONION-PREPARATION" "FRY-PREPARATION" :success)
    (send sm-top :add-transition "FRY-PREPARATION" "FRY-ONION" :success)
    (send sm-top :add-transition "FRY-ONION" "FRY-MEAT" :success)
    (send sm-top :add-transition "FRY-MEAT" "STEW-PREPARATION" :success)
    (send sm-top :add-transition "STEW-PREPARATION" "STEW" :success)
    (send sm-top :add-transition "STEW" "CURRY-ROUX" :success)    
    (send sm-top :add-transition "CURRY-ROUX" :done :success)
    
    ;; node instance can be args of :add-node, :start-state, :add-transition
    ;; sm-sub-0 ;;curry-0 preparation
    (let ((set-in-shelf-node (instance state :init "SET-IN-SHELF" '(lambda (&rest args) (curry-0-1) :success)))
          (set-bowl-1 (instance state :init "SET-BOWL-1" '(lambda (&rest args) (curry-0-2) :success)))
          (set-vegs (instance state :init "SET-VEGS" '(lambda (&rest args) (curry-0-3) :success)))
          (set-mcup (instance state :init "SET-MCUP" '(lambda (&rest args) (curry-0-4) :success)))
          (move-to-stove (instance state :init "MOVE-TO-STOVE" '(lambda (&rest args) (curry-0-5) :success)))
          (set-bowl-2-3 (instance state :init "SET-BOWL-2-3" '(lambda (&rest args) (curry-0-6) :success)))
          (move-to-kitchen (instance state :init "MOVE-TO-KITCHEN" '(lambda (&rest args) (curry-0-7) :success)))
          (set-board (instance state :init "SET-BOARD" '(lambda (&rest args) (curry-0-8) :success)))
          (set-tools-on-table (instance state :init "SET-TOOLS-ON-TABLE" '(lambda (&rest args) (curry-0-9) :success)))
          )
      (send sm-sub-0 :add-node set-in-shelf-node)
      (send sm-sub-0 :add-node set-bowl-1)
      (send sm-sub-0 :add-node set-vegs)
      (send sm-sub-0 :add-node set-mcup)
      (send sm-sub-0 :add-node move-to-stove)
      (send sm-sub-0 :add-node set-bowl-2-3)
      (send sm-sub-0 :add-node move-to-kitchen)
      (send sm-sub-0 :add-node set-board)
      (send sm-sub-0 :add-node set-tools-on-table)
      
      (send sm-sub-0 :goal-state :success)
      
      (send sm-sub-0 :start-state set-in-shelf-node)
      (send sm-sub-0 :add-transition set-in-shelf-node set-bowl-1 :success)
      (send sm-sub-0 :add-transition set-bowl-1 set-vegs :success)
      (send sm-sub-0 :add-transition set-vegs set-mcup :success)
      (send sm-sub-0 :add-transition set-mcup move-to-stove :success)
      (send sm-sub-0 :add-transition move-to-stove set-bowl-2-3 :success)
      (send sm-sub-0 :add-transition set-bowl-2-3 move-to-kitchen :success)
      (send sm-sub-0 :add-transition move-to-kitchen set-board :success)
      (send sm-sub-0 :add-transition set-board set-tools-on-table :success)
      (send sm-sub-0 :add-transition set-tools-on-table :success :success)      
      )
    
    ;; sm-sub-1 ;;curry-1 carrot-preparation
    (let ((grasp-carrot-node (instance state :init "GRASP-CARROT" '(lambda (&rest args) (curry-1-1) :success)))
          (move-to-sink-node (instance state :init "MOVE-TO-SINK" '(lambda (&rest args) (curry-1-2) :success)))
          (wash-carrot-node (instance state :init "WASH-CARROT" '(lambda (&rest args) (curry-1-3) :success)))
          (move-to-kitchen-node (instance state :init "MOVE-TO-KITCHEN" '(lambda (&rest args) (curry-1-4) :success)))
          (put-carrot-on-board-node (instance state :init "PUT-CARROT-ON-BOARD" '(lambda (&rest args) (curry-1-5) :success)))
          (grasp-peeler-node (instance state :init "GRASP-PEELER" '(lambda (&rest args) (curry-1-6) :success)))
          (peel-carrot-node (instance state :init "PEEL-CARROT" '(lambda (&rest args) (curry-1-7) :success)))
          (replace-tool-node (instance state :init "REPLACE-TOOL" '(lambda (&rest args) (curry-1-8) :success)))
          (cut-carrot-node (instance state :init "CUT-CARROT" '(lambda (&rest args) (curry-1-9) :success)))
          (put-knife-node (instance state :init "PUT-KNIFE" '(lambda (&rest args) (curry-1-10) :success)))
          (transfer-to-bowl-1-node (instance state :init "TRANSFER-TO-BOWL-1" '(lambda (&rest args) (curry-1-11) :success)))
          )
      (send sm-sub-1 :add-node grasp-carrot-node)
      (send sm-sub-1 :add-node move-to-sink-node)
      (send sm-sub-1 :add-node wash-carrot-node)
      (send sm-sub-1 :add-node move-to-kitchen-node)
      (send sm-sub-1 :add-node put-carrot-on-board-node)
      (send sm-sub-1 :add-node grasp-peeler-node)
      (send sm-sub-1 :add-node peel-carrot-node)
      (send sm-sub-1 :add-node replace-tool-node)
      (send sm-sub-1 :add-node cut-carrot-node)
      (send sm-sub-1 :add-node put-knife-node)
      (send sm-sub-1 :add-node transfer-to-bowl-1-node)
      
      (send sm-sub-1 :goal-state :success)
      
      (send sm-sub-1 :start-state grasp-carrot-node)
      (send sm-sub-1 :add-transition grasp-carrot-node move-to-sink-node :success)
      (send sm-sub-1 :add-transition move-to-sink-node wash-carrot-node :success)
      (send sm-sub-1 :add-transition wash-carrot-node move-to-kitchen-node :success)
      (send sm-sub-1 :add-transition move-to-kitchen-node put-carrot-on-board-node :success)
      (send sm-sub-1 :add-transition put-carrot-on-board-node grasp-peeler-node :success)
      (send sm-sub-1 :add-transition grasp-peeler-node peel-carrot-node :success)
      (send sm-sub-1 :add-transition peel-carrot-node replace-tool-node :success)
      (send sm-sub-1 :add-transition replace-tool-node cut-carrot-node :success)
      (send sm-sub-1 :add-transition cut-carrot-node put-knife-node :success)
      (send sm-sub-1 :add-transition put-knife-node transfer-to-bowl-1-node :success)
      (send sm-sub-1 :add-transition transfer-to-bowl-1-node :success :success)
      )

    ;; sm-sub-2 ;;curry-2 potato-preparation
    (let ((grasp-potato-node (instance state :init "GRASP-POTATO" '(lambda (&rest args) (curry-2-1) :success)))
          (move-to-sink-node (instance state :init "MOVE-TO-SINK" '(lambda (&rest args) (curry-2-2) :success)))
          (wash-potato-node (instance state :init "WASH-POTATO" '(lambda (&rest args) (curry-2-3) :success)))
          (move-to-kitchen-node (instance state :init "MOVE-TO-KITCHEN" '(lambda (&rest args) (curry-2-4) :success)))
          (put-potato-on-board-node (instance state :init "PUT-POTATO-ON-BOARD" '(lambda (&rest args) (curry-2-5) :success)))
          (grasp-potato-peeler-node (instance state :init "GRASP-POTATO-PEELER" '(lambda (&rest args) (curry-2-6) :success)))
          (peel-potato-node (instance state :init "PEEL-POTATO" '(lambda (&rest args) (curry-2-7) :success)))
          (replace-tool-node (instance state :init "REPLACE-TOOL" '(lambda (&rest args) (curry-2-8) :success)))
          (cut-potato-node (instance state :init "CUT-POTATO" '(lambda (&rest args) (curry-2-9) :success)))
          (put-knife-node (instance state :init "PUT-KNIFE" '(lambda (&rest args) (curry-2-10) :success)))
          (transfer-to-bowl-1-node (instance state :init "TRANSFER-TO-BOWL-1" '(lambda (&rest args) (curry-2-11) :success)))
          )
      (send sm-sub-2 :add-node grasp-potato-node)
      (send sm-sub-2 :add-node move-to-sink-node)
      (send sm-sub-2 :add-node wash-potato-node)
      (send sm-sub-2 :add-node move-to-kitchen-node)
      (send sm-sub-2 :add-node put-potato-on-board-node)
      (send sm-sub-2 :add-node grasp-potato-peeler-node)
      (send sm-sub-2 :add-node peel-potato-node)
      (send sm-sub-2 :add-node replace-tool-node)
      (send sm-sub-2 :add-node cut-potato-node)
      (send sm-sub-2 :add-node put-knife-node)
      (send sm-sub-2 :add-node transfer-to-bowl-1-node)
      
      (send sm-sub-2 :goal-state :success)
      
      (send sm-sub-2 :start-state grasp-potato-node)
      (send sm-sub-2 :add-transition grasp-potato-node move-to-sink-node :success)
      (send sm-sub-2 :add-transition move-to-sink-node wash-potato-node :success)
      (send sm-sub-2 :add-transition wash-potato-node move-to-kitchen-node :success)
      (send sm-sub-2 :add-transition move-to-kitchen-node put-potato-on-board-node :success)
      (send sm-sub-2 :add-transition put-potato-on-board-node grasp-potato-peeler-node :success)
      (send sm-sub-2 :add-transition grasp-potato-peeler-node peel-potato-node :success)
      (send sm-sub-2 :add-transition peel-potato-node replace-tool-node :success)
      (send sm-sub-2 :add-transition replace-tool-node cut-potato-node :success)
      (send sm-sub-2 :add-transition cut-potato-node put-knife-node :success)
      (send sm-sub-2 :add-transition put-knife-node transfer-to-bowl-1-node :success)
      (send sm-sub-2 :add-transition transfer-to-bowl-1-node :success :success)      
      )
    
    ;; sm-sub-3 ;;curry-3 onion-preparation
    (let ((grasp-onion-node (instance state :init "GRASP-ONION" '(lambda (&rest args) (curry-3-1) :success)))
          (move-to-sink-node (instance state :init "MOVE-TO-SINK" '(lambda (&rest args) (curry-3-2) :success)))
          (wash-onion-node (instance state :init "WASH-ONION" '(lambda (&rest args) (curry-3-3) :success)))
          (move-to-kitchen-node (instance state :init "MOVE-TO-KITCHEN" '(lambda (&rest args) (curry-3-4) :success)))
          (put-onion-on-board-node (instance state :init "PUT-ONION-ON-BOARD" '(lambda (&rest args) (curry-3-5) :success)))
          (grasp-knife-node (instance state :init "GRASP-KNIFE" '(lambda (&rest args) (curry-3-6) :success)))
          (cut-onion-node (instance state :init "CUT-ONION" '(lambda (&rest args) (curry-3-7) :success)))
          (put-knife-node (instance state :init "PUT-KNIFE" '(lambda (&rest args) (curry-3-8) :success)))
          (transfer-to-pot-node (instance state :init "TRANSFER-TO-POT" '(lambda (&rest args) (curry-3-9) :success)))
          )
      (send sm-sub-3 :add-node grasp-onion-node)
      (send sm-sub-3 :add-node move-to-sink-node)
      (send sm-sub-3 :add-node wash-onion-node)
      (send sm-sub-3 :add-node move-to-kitchen-node)
      (send sm-sub-3 :add-node put-onion-on-board-node)
      (send sm-sub-3 :add-node grasp-knife-node)
      (send sm-sub-3 :add-node cut-onion-node)
      (send sm-sub-3 :add-node put-knife-node)
      (send sm-sub-3 :add-node transfer-to-pot-node)
      
      (send sm-sub-3 :goal-state :success)
      
      (send sm-sub-3 :start-state grasp-onion-node)
      (send sm-sub-3 :add-transition grasp-onion-node move-to-sink-node :success)
      (send sm-sub-3 :add-transition move-to-sink-node wash-onion-node :success)
      (send sm-sub-3 :add-transition wash-onion-node move-to-kitchen-node :success)
      (send sm-sub-3 :add-transition move-to-kitchen-node put-onion-on-board-node :success)
      (send sm-sub-3 :add-transition put-onion-on-board-node grasp-knife-node :success)
      (send sm-sub-3 :add-transition grasp-knife-node cut-onion-node :success)
      (send sm-sub-3 :add-transition cut-onion-node put-knife-node :success)
      (send sm-sub-3 :add-transition put-knife-node transfer-to-pot-node :success)
      (send sm-sub-3 :add-transition transfer-to-pot-node :success :success)      
      )

    ;; sm-sub-4 ;;curry-4 fry-preparation
    (let ((set-from-shelf-node (instance state :init "SET-FROM-SHELF" '(lambda (&rest args) (curry-4-1) :success)))
          (move-to-stove-node (instance state :init "MOVE-TO-STOVE" '(lambda (&rest args) (curry-4-2) :success)))
          (add-oil-node (instance state :init "ADD-OIL" '(lambda (&rest args) (curry-4-3) :success)))
          )
      (send sm-sub-4 :add-node set-from-shelf-node)
      (send sm-sub-4 :add-node move-to-stove-node)
      (send sm-sub-4 :add-node add-oil-node)
      
      (send sm-sub-4 :goal-state :success)
      
      (send sm-sub-4 :start-state set-from-shelf-node)
      (send sm-sub-4 :add-transition set-from-shelf-node move-to-stove-node :success)
      (send sm-sub-4 :add-transition move-to-stove-node add-oil-node :success)
      (send sm-sub-4 :add-transition add-oil-node :success :success)
      )
    
    
    sm-top))

    
  ;; (let (sm)
  ;;   (setq count 0) ;; 失敗した数を数える．
  ;;   (setq sm
  ;;         (make-state-machine
  ;;          ;; define graph,  list of (<from-node> <transition> <to-node>)
  ;;          ;; if <transition> is ->, it corresponds when node returns t and !-> for nil.
  ;;          '((:init :success :preparation)
  ;;            (:preparation :success :carrot-preparation)
  ;;            (:carrot-preparation :success :potato-preparation)
  ;;            (:potato-preparation :success :onion-preparation)
  ;;            (:onion-preparation :success :fry-preparation)
  ;;            (:fry-preparation :success :fry-onion)
  ;;            (:fry-onion :success :fry-meat)
  ;;            (:fry-meat :success :stew-preparation)
  ;;            (:stew-preparation :success :stew)
  ;;            (:stew :success :curry-roux)
  ;;            (:curry-roux :success :done)
  ;;            )
  ;;          ;; define function map
  ;;          '((:init '(lambda (&rest args) (init) :success))
  ;;            (:preparation '(lambda (&rest args) (curry-0) :success))
  ;;            (:carrot-preparation '(lambda (&rest args) (curry-1) :success))
  ;;            (:potato-preparation '(lambda (&rest args) (curry-2) :success))
  ;;            (:onion-preparation '(lambda (&rest args) (curry-3) :success))
  ;;            (:fry-preparation '(lambda (&rest args) (curry-4) :success))
  ;;            (:fry-onion '(lambda (&rest args) (curry-5) :success))
  ;;            (:fry-meat '(lambda (&rest args) (curry-6) :success))
  ;;            (:stew-preparation '(lambda (&rest args) (curry-7) :success))
  ;;            (:stew '(lambda (&rest args) (curry-8) :success))
  ;;            (:curry-roux '(lambda (&rest args) (curry-9) :success))
  ;;            )
  ;;          ;; initial state
  ;;          '(:init)
  ;;          ;; goal state
  ;;          '(:done)))))

(defun smach-demo ()
  (ros::roseus "smach_demo")
  (exec-state-machine (smach-curry-test)))

(format t ";; to run with smachk, run ~% (smach-demo) ~%")

